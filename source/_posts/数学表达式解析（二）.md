---
title: 数学表达式解析（二）
date: 2018-05-18 11:53:43
tags:
---



​	之前已经解决了函数表达式的存储问题，通过简单的基础函数类型，构造出复杂的表达式，例如有表达式：

$$
x*(x+1)^2+5*x
$$
可以拆分为$$x*(x+1)^2$$和$$5*x$$，$$x*(x+1)^2$$可拆分为$$x$$和$$(x+1)^2$$，$$(x+1)^2$$可拆为$$x+1$$和$$2$$。按照表达式的存储方式来构造：
```c++
//构造（x*(x+1)^2）:
auto pow_expr = std::make_shared<fp::power_function>(std::make_shared<fp::add_function>(std::make_shared<fp::independent_variable>("x"), std::make_shared<fp::constant_function>(1)), std::make_shared<fp::constant_function>(2));
auto expr1 = std::make_shared<fp::multiply_function>(std::make_shared<fp::independent_variable>("x"), pow_expr);
//构造（5*x）:
auto expr2 = std::make_shared<fp::multiply_function>(std::make_shared<fp::constant_function>(5), std::make_shared<fp::independent_variable>("x"));
//组合：
auto final_expr = std::make_shared<fp::add_function>(expr1, expr2);
std::cout << final_expr->str() << std::endl;
std::cout << final_expr->derivative()->str();
```

输出

```
((x*((x+1)^2))+(5*x))
(((1*((x+1)^2))+(x*(((x+1)^2)*((0*(ln(x+1)))+(2*((1/(x+1))*(1+0)))))))+((0*x)+(5*1)))
```

这是在已知表达式来构造的情况，然而一般情况下，用户输入什么表达式都是未知的，因此需要对字符串进行解析来自动生成表达式。

## 解析函数

​	一般表达式都是多层嵌套的，所以使用递归来解析函数表达式。

```c++
base_function_ptr function_parse(std::string func_str);
```



### 初步处理

​	传入的字符串可能含有空格或者被括号括起来，例如$$( x + 1 )$$，不方便处理，所以，首先要去空格和最外层括号：

```c++
func_str.erase(std::remove_if(func_str.begin(), func_str.end(),
	[](char c) {return c == ' '; }), func_str.end());
while ((!func_str.empty()) && func_str.at(0) == '('&&get_matching_bracket(func_str, 0) == (func_str.size() - 1))
{
	func_str.erase(func_str.begin());
	func_str.pop_back();
}
```

### ln,sin,cos的解析

​	如果传入的字符串最外层已经是一个数学函数了，那么就直接返回构造的指针。观察这样的字符串：$$ln(x+1)$$，可以看出基本特征：

- 最后一个字符为')'

- 与最后一个')'相对应的'('位置之前的字符串不含有括号以及其他操作符

- 与最后一个')'相对应的'('位置之间的字符串也是一个表达式

  按照这三条规则编写：
```c++
if (func_str.at(func_str.size() - 1) == ')')
{
	unsigned int fb = get_matching_bracket(func_str, func_str.size() - 1);
	if (fb == -1)
	{
		throw std::invalid_argument("fail to parse");
	}
	auto func_name = func_str.substr(0, fb);
	if (!(include_brackets(func_name) || include_operators(func_name)))
	{
		if (func_name == "ln")
		{
			return std::make_shared<ln_function>(function_parse(func_str.substr(fb, func_str.size() - fb)));
		}
		else if (func_name == "sin")
		{
			return std::make_shared<sin_function>(function_parse(func_str.substr(fb, func_str.size() - fb)));
		}
		else if (func_name == "cos")
		{
			return std::make_shared<cos_function>(function_parse(func_str.substr(fb, func_str.size() - fb)));
		}
	}
}
```


### 递归终止条件

​	递归终止只有两种可能性，一是传入的字符串就是自变量，二是一个常数。所以通过是否包含操作符和是否数字来判断：

```c++
if (!include_operators(func_str))
{
	if (is_number(func_str))
	{
		return std::make_shared<constant_function>(std::atof(func_str.c_str()));
	}
	else
	{
		return std::make_shared<independent_variable>(func_str);
	}
}
```

### 按照优先级解析表达式

​	循环遍历表达式字符串，如果遇到+或者-就把当前位置添加到数组中。另外，如果遇到'('，就直接跳转到相对应的')'位置，这样就解决了括号的问题。然后使用数组里的位置将字符串分段，每段再递归调用function_pasre，最后使用add_function或者minus_function把它们全部组合并直接返回。如果数组内没有元素，就按相同的方法来依次解析乘除和乘方。

##  [项目地址](https://github.com/cildhdi/function_parsing)

示例：main.cpp  

```c++
#include "function_parsing.h"
#include <iostream>
int main()
{
	std::string str;
	std::cout << "input f(x)= ";
	std::cin >> str;
	try
	{
		auto f = fp::function_parse(str);
		auto fd = f->derivative();
		std::cout << "f(x)=" << f->str() << std::endl;
		std::cout << "f'(x)=" << fd->str() << std::endl;
		double x;
		std::cout << "input x= ";
		std::cin >> x;
		std::cout << "f(" << x << ")=" << f->value(x) << std::endl;
		std::cout << "f'(" << x << ")=" << fd->value(x) << std::endl;
	}
	catch (std::exception& e)
	{
		std::cout << "fail to parse:" << e.what();
	}
	return 0;
}
```

输入x+x*sin(x+1)/3 与 3，则有输出：

```
input f(x)= x+x*sin(x+1)/3
f(x)=(x+((x*(sin(x+1)))/3))
f'(x)=(1+(((((1*(sin(x+1)))+(x*((cos(x+1))*(1+0))))*3)-((x*(sin(x+1)))*0))/(3*3)))
input x= 3
f(3)=2.2432
f'(3)=0.0940889
```